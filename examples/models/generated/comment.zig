// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: ./examples/schemas/comment.json
// To regenerate: zig run scripts/generate_model.zig -- ./examples/schemas/comment.json

const std = @import("std");

const pg = @import("pg");

const AuthUser = @import("auth_user.zig").AuthUser;
const BaseModel = @import("base.zig").BaseModel;
const Post = @import("post.zig").Post;
const QueryBuilder = @import("query.zig").QueryBuilder;
const Transaction = @import("transaction.zig").Transaction;

// Related models
const Comment = @This();

// Fields
id: []const u8,
post_id: []const u8,
user_id: []const u8,
content: []const u8,
created_at: i64,
updated_at: i64,

// Input type for creating new records
pub const CreateInput = struct {
    post_id: []const u8,
    user_id: []const u8,
    content: []const u8,
};

// Input type for updating existing records
pub const UpdateInput = struct {
    post_id: ?[]const u8 = null,
    user_id: ?[]const u8 = null,
    content: ?[]const u8 = null,
};

// Model configuration
pub fn tableName() []const u8 {
    return "comments";
}

pub fn createTableSQL() []const u8 {
    return 
    \\CREATE TABLE IF NOT EXISTS comments (
    \\    id UUID PRIMARY KEY NOT NULL DEFAULT gen_random_uuid(),
    \\    post_id UUID NOT NULL,
    \\    user_id UUID NOT NULL,
    \\    content TEXT NOT NULL,
    \\    created_at TIMESTAMP NOT NULL DEFAULT now(),
    \\    updated_at TIMESTAMP NOT NULL DEFAULT now(),
    \\    CONSTRAINT post FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    \\    CONSTRAINT author FOREIGN KEY (user_id) REFERENCES auth_users(id) ON DELETE CASCADE
    \\)
    ;
}

pub fn createIndexSQL() []const []const u8 {
    return &[_][]const u8{
        "CREATE INDEX IF NOT EXISTS idx_comments_post ON comments (post_id)",
        "CREATE INDEX IF NOT EXISTS idx_comments_user ON comments (user_id)",
    };
}

pub fn dropIndexSQL() []const []const u8 {
    return &[_][]const u8{
        "DROP INDEX IF EXISTS idx_comments_post",
        "DROP INDEX IF EXISTS idx_comments_user",
    };
}

pub fn insertSQL() []const u8 {
    return 
    \\INSERT INTO comments (
    \\    post_id, user_id, content
    \\) VALUES ($1, $2, $3)
    \\RETURNING id
    ;
}

pub fn insertParams(data: CreateInput) struct {
    []const u8,
    []const u8,
    []const u8,
} {
    return .{
        data.post_id,
        data.user_id,
        data.content,
    };
}

pub fn updateSQL() []const u8 {
    return 
    \\UPDATE comments SET
    \\    post_id = COALESCE($2, post_id),
    \\    user_id = COALESCE($3, user_id),
    \\    content = COALESCE($4, content),
    \\    updated_at = CURRENT_TIMESTAMP
    \\WHERE id = $1
    ;
}

pub fn updateParams(id: []const u8, data: UpdateInput) struct {
    []const u8,
    ?[]const u8,
    ?[]const u8,
    ?[]const u8,
} {
    return .{
        id,
        data.post_id,
        data.user_id,
        data.content,
    };
}

const base = BaseModel(Comment);
// DDL operations
pub const createTable = base.createTable;

pub const dropTable = base.dropTable;

pub const createIndexes = base.createIndexes;

pub const dropIndexes = base.dropIndexes;

pub const truncate = base.truncate;

pub const tableExists = base.tableExists;

// CRUD operations
pub const findById = base.findById;

pub const findAll = base.findAll;

pub const insert = base.insert;

pub const insertAndReturn = base.insertAndReturn;

pub const update = base.update;

pub const updateAndReturn = base.updateAndReturn;

pub const upsert = base.upsert;

pub const upsertAndReturn = base.upsertAndReturn;

pub const softDelete = base.softDelete;

pub const hardDelete = base.hardDelete;

pub const count = base.count;

pub const fromRow = base.fromRow;

pub fn query() QueryBuilder(Comment, UpdateInput) {
    return QueryBuilder(Comment, UpdateInput).init();
}

/// JSON-safe response struct with UUIDs as hex strings
pub const JsonResponse = struct {
    id: [36]u8,
    post_id: [36]u8,
    user_id: [36]u8,
    content: []const u8,
    created_at: i64,
    updated_at: i64,
};

/// Convert model to JSON-safe response with UUIDs as hex strings
pub fn toJsonResponse(self: Comment) !JsonResponse {
    return JsonResponse{
        .id = try pg.uuidToHex(&self.id[0..16].*),
        .post_id = try pg.uuidToHex(&self.post_id[0..16].*),
        .user_id = try pg.uuidToHex(&self.user_id[0..16].*),
        .content = self.content,
        .created_at = self.created_at,
        .updated_at = self.updated_at,
    };
}

/// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
pub const JsonResponseSafe = struct {
    id: [36]u8,
    post_id: [36]u8,
    user_id: [36]u8,
    content: []const u8,
    created_at: i64,
    updated_at: i64,
};

/// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
pub fn toJsonResponseSafe(self: Comment) !JsonResponseSafe {
    return JsonResponseSafe{
        .id = try pg.uuidToHex(&self.id[0..16].*),
        .post_id = try pg.uuidToHex(&self.post_id[0..16].*),
        .user_id = try pg.uuidToHex(&self.user_id[0..16].*),
        .content = self.content,
        .created_at = self.created_at,
        .updated_at = self.updated_at,
    };
}
// Relationship methods
/// Fetch the related Post record for this Comment
pub fn fetchPost(self: *const Comment, db: *pg.Pool, allocator: std.mem.Allocator) !?Post {
    return Post.findById(db, allocator, self.post_id);
}

/// Fetch the related AuthUser record for this Comment
pub fn fetchUser(self: *const Comment, db: *pg.Pool, allocator: std.mem.Allocator) !?AuthUser {
    return AuthUser.findById(db, allocator, self.user_id);
}

// Transaction support
pub const TransactionType = Transaction(Comment);

pub fn beginTransaction(conn: *pg.Conn) !TransactionType {
    return TransactionType.begin(conn);
}
