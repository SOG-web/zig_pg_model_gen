// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: ./examples/schemas/auth_user.json
// To regenerate: zig run scripts/generate_model.zig -- ./examples/schemas/auth_user.json

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("base.zig").BaseModel;
const QueryBuilder = @import("query.zig").QueryBuilder;
const Transaction = @import("transaction.zig").Transaction;

const AuthUser = @This();

    // Fields
id: []const u8,
email: []const u8,
phone_number: []const u8,
user_type: []const u8,
password: []const u8,
created_at: i64,
updated_at: i64,
deleted_at: ?i64,
is_active: bool,
is_verified: bool,
is_email_verified: bool,
is_phone_verified: bool,
last_login: ?i64,
profile_image_url: ?[]const u8,
otp: ?[]const u8,
email_otp: ?[]const u8,
phone_number_otp: ?[]const u8,
phone_otp_created_at: ?i64,
email_otp_created_at: ?i64,


    // Input type for creating new records
    pub const CreateInput = struct {
        email: []const u8,
        phone_number: []const u8,
        user_type: []const u8,
        password: []const u8,
        deleted_at: ?i64 = null,
        is_active: ?bool = null,
        is_verified: ?bool = null,
        is_email_verified: ?bool = null,
        is_phone_verified: ?bool = null,
        last_login: ?i64 = null,
        profile_image_url: ?[]const u8 = null,
        otp: ?[]const u8 = null,
        email_otp: ?[]const u8 = null,
        phone_number_otp: ?[]const u8 = null,
        phone_otp_created_at: ?i64 = null,
        email_otp_created_at: ?i64 = null,
    };

    // Input type for updating existing records
    pub const UpdateInput = struct {
        email: ?[]const u8 = null,
        phone_number: ?[]const u8 = null,
        user_type: ?[]const u8 = null,
        password: ?[]const u8 = null,
        deleted_at: ?i64 = null,
        is_active: ?bool = null,
        is_verified: ?bool = null,
        is_email_verified: ?bool = null,
        is_phone_verified: ?bool = null,
        last_login: ?i64 = null,
        profile_image_url: ?[]const u8 = null,
        otp: ?[]const u8 = null,
        email_otp: ?[]const u8 = null,
        phone_number_otp: ?[]const u8 = null,
        phone_otp_created_at: ?i64 = null,
        email_otp_created_at: ?i64 = null,
    };

    // Model configuration
    pub fn tableName() []const u8 {
        return "auth_users";
    }

    pub fn createTableSQL() []const u8 {
        return
            \\CREATE TABLE IF NOT EXISTS auth_users (
            \\    id UUID PRIMARY KEY NOT NULL DEFAULT gen_random_uuid(),
            \\    email TEXT NOT NULL UNIQUE,
            \\    phone_number TEXT NOT NULL UNIQUE,
            \\    user_type TEXT NOT NULL,
            \\    password TEXT NOT NULL,
            \\    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
            \\    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
            \\    deleted_at TIMESTAMP,
            \\    is_active BOOLEAN NOT NULL DEFAULT TRUE,
            \\    is_verified BOOLEAN NOT NULL DEFAULT FALSE,
            \\    is_email_verified BOOLEAN NOT NULL DEFAULT FALSE,
            \\    is_phone_verified BOOLEAN NOT NULL DEFAULT FALSE,
            \\    last_login TIMESTAMP,
            \\    profile_image_url TEXT,
            \\    otp TEXT,
            \\    email_otp TEXT,
            \\    phone_number_otp TEXT,
            \\    phone_otp_created_at TIMESTAMP,
            \\    email_otp_created_at TIMESTAMP
            \\)
        ;
    }

    pub fn createIndexSQL() []const []const u8 {
        return &[_][]const u8{
            "CREATE UNIQUE INDEX IF NOT EXISTS idx_auth_users_email ON auth_users (email)",
            "CREATE UNIQUE INDEX IF NOT EXISTS idx_auth_users_phone_number ON auth_users (phone_number)",
        };
    }

    pub fn dropIndexSQL() []const []const u8 {
        return &[_][]const u8{
            "DROP INDEX IF EXISTS idx_auth_users_email",
            "DROP INDEX IF EXISTS idx_auth_users_phone_number",
        };
    }

    pub fn insertSQL() []const u8 {
        return
            \\INSERT INTO auth_users (
            \\    email, phone_number, user_type, password, deleted_at, is_active, is_verified, is_email_verified, is_phone_verified, last_login, profile_image_url, otp, email_otp, phone_number_otp, phone_otp_created_at, email_otp_created_at
            \\) VALUES ($1, $2, $3, $4, $5, COALESCE($6, TRUE), COALESCE($7, FALSE), COALESCE($8, FALSE), COALESCE($9, FALSE), $10, $11, $12, $13, $14, $15, $16)
            \\RETURNING id
        ;
    }

    pub fn insertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        ?i64,
        ?bool,
        ?bool,
        ?bool,
        ?bool,
        ?i64,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?i64,
        ?i64,
    } {
        return .{
            data.email,
            data.phone_number,
            data.user_type,
            data.password,
            data.deleted_at,
            data.is_active,
            data.is_verified,
            data.is_email_verified,
            data.is_phone_verified,
            data.last_login,
            data.profile_image_url,
            data.otp,
            data.email_otp,
            data.phone_number_otp,
            data.phone_otp_created_at,
            data.email_otp_created_at,
        };
    }

    pub fn updateSQL() []const u8 {
        return
            \\UPDATE auth_users SET
            \\    email = COALESCE($2, email),
            \\    phone_number = COALESCE($3, phone_number),
            \\    user_type = COALESCE($4, user_type),
            \\    password = COALESCE($5, password),
            \\    deleted_at = COALESCE($6, deleted_at),
            \\    is_active = COALESCE($7, is_active),
            \\    is_verified = COALESCE($8, is_verified),
            \\    is_email_verified = COALESCE($9, is_email_verified),
            \\    is_phone_verified = COALESCE($10, is_phone_verified),
            \\    last_login = COALESCE($11, last_login),
            \\    profile_image_url = COALESCE($12, profile_image_url),
            \\    otp = COALESCE($13, otp),
            \\    email_otp = COALESCE($14, email_otp),
            \\    phone_number_otp = COALESCE($15, phone_number_otp),
            \\    phone_otp_created_at = COALESCE($16, phone_otp_created_at),
            \\    email_otp_created_at = COALESCE($17, email_otp_created_at),
            \\    updated_at = CURRENT_TIMESTAMP
            \\WHERE id = $1
        ;
    }

    pub fn updateParams(id: []const u8, data: UpdateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?i64,
        ?bool,
        ?bool,
        ?bool,
        ?bool,
        ?i64,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?i64,
        ?i64,
    } {
        return .{
            id,
            data.email,
            data.phone_number,
            data.user_type,
            data.password,
            data.deleted_at,
            data.is_active,
            data.is_verified,
            data.is_email_verified,
            data.is_phone_verified,
            data.last_login,
            data.profile_image_url,
            data.otp,
            data.email_otp,
            data.phone_number_otp,
            data.phone_otp_created_at,
            data.email_otp_created_at,
        };
    }

    pub fn upsertSQL() []const u8 {
        return
            \\INSERT INTO auth_users (
            \\    email, phone_number, user_type, password, deleted_at, is_active, is_verified, is_email_verified, is_phone_verified, last_login, profile_image_url, otp, email_otp, phone_number_otp, phone_otp_created_at, email_otp_created_at
            \\) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
            \\ON CONFLICT (email) DO UPDATE SET
            \\    user_type = EXCLUDED.user_type,
            \\    password = EXCLUDED.password,
            \\    deleted_at = EXCLUDED.deleted_at,
            \\    is_active = EXCLUDED.is_active,
            \\    is_verified = EXCLUDED.is_verified,
            \\    is_email_verified = EXCLUDED.is_email_verified,
            \\    is_phone_verified = EXCLUDED.is_phone_verified,
            \\    last_login = EXCLUDED.last_login,
            \\    profile_image_url = EXCLUDED.profile_image_url,
            \\    otp = EXCLUDED.otp,
            \\    email_otp = EXCLUDED.email_otp,
            \\    phone_number_otp = EXCLUDED.phone_number_otp,
            \\    phone_otp_created_at = EXCLUDED.phone_otp_created_at,
            \\    email_otp_created_at = EXCLUDED.email_otp_created_at,
            \\    updated_at = CURRENT_TIMESTAMP
            \\RETURNING id
        ;
    }

    pub fn upsertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        ?i64,
        ?bool,
        ?bool,
        ?bool,
        ?bool,
        ?i64,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?i64,
        ?i64,
    } {
        return .{
            data.email,
            data.phone_number,
            data.user_type,
            data.password,
            data.deleted_at,
            data.is_active,
            data.is_verified,
            data.is_email_verified,
            data.is_phone_verified,
            data.last_login,
            data.profile_image_url,
            data.otp,
            data.email_otp,
            data.phone_number_otp,
            data.phone_otp_created_at,
            data.email_otp_created_at,
        };
    }

    const base = BaseModel(AuthUser);
    // DDL operations
    pub const createTable = base.createTable;

    pub const dropTable = base.dropTable;

    pub const createIndexes = base.createIndexes;

    pub const dropIndexes = base.dropIndexes;

    pub const truncate = base.truncate;

    pub const tableExists = base.tableExists;

    // CRUD operations
    pub const findById = base.findById;

    pub const findAll = base.findAll;

    pub const insert = base.insert;

    pub const insertAndReturn = base.insertAndReturn;

    pub const update = base.update;

    pub const updateAndReturn = base.updateAndReturn;

    pub const upsert = base.upsert;

    pub const upsertAndReturn = base.upsertAndReturn;

    pub const softDelete = base.softDelete;

    pub const hardDelete = base.hardDelete;

    pub const count = base.count;

    pub const fromRow = base.fromRow;

    pub fn query() QueryBuilder(AuthUser, UpdateInput) {
        return QueryBuilder(AuthUser, UpdateInput).init();
    }


    /// JSON-safe response struct with UUIDs as hex strings
    pub const JsonResponse = struct {
        id: [36]u8,
        email: []const u8,
        phone_number: []const u8,
        user_type: []const u8,
        password: []const u8,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
        is_active: bool,
        is_verified: bool,
        is_email_verified: bool,
        is_phone_verified: bool,
        last_login: ?i64,
        profile_image_url: ?[]const u8,
        otp: ?[]const u8,
        email_otp: ?[]const u8,
        phone_number_otp: ?[]const u8,
        phone_otp_created_at: ?i64,
        email_otp_created_at: ?i64,
    };

    /// Convert model to JSON-safe response with UUIDs as hex strings
    pub fn toJsonResponse(self: AuthUser) !JsonResponse {
        return JsonResponse{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .email = self.email,
            .phone_number = self.phone_number,
            .user_type = self.user_type,
            .password = self.password,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
            .is_active = self.is_active,
            .is_verified = self.is_verified,
            .is_email_verified = self.is_email_verified,
            .is_phone_verified = self.is_phone_verified,
            .last_login = self.last_login,
            .profile_image_url = self.profile_image_url,
            .otp = self.otp,
            .email_otp = self.email_otp,
            .phone_number_otp = self.phone_number_otp,
            .phone_otp_created_at = self.phone_otp_created_at,
            .email_otp_created_at = self.email_otp_created_at,
        };
    }

    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
    pub const JsonResponseSafe = struct {
        id: [36]u8,
        email: []const u8,
        phone_number: []const u8,
        user_type: []const u8,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
        is_active: bool,
        is_verified: bool,
        is_email_verified: bool,
        is_phone_verified: bool,
        last_login: ?i64,
        profile_image_url: ?[]const u8,
        phone_otp_created_at: ?i64,
        email_otp_created_at: ?i64,
    };

    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
    pub fn toJsonResponseSafe(self: AuthUser) !JsonResponseSafe {
        return JsonResponseSafe{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .email = self.email,
            .phone_number = self.phone_number,
            .user_type = self.user_type,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
            .is_active = self.is_active,
            .is_verified = self.is_verified,
            .is_email_verified = self.is_email_verified,
            .is_phone_verified = self.is_phone_verified,
            .last_login = self.last_login,
            .profile_image_url = self.profile_image_url,
            .phone_otp_created_at = self.phone_otp_created_at,
            .email_otp_created_at = self.email_otp_created_at,
        };
    }
    // Transaction support
    pub const TransactionType = Transaction(AuthUser);

    pub fn beginTransaction(conn: *pg.Conn) !TransactionType {
        return TransactionType.begin(conn);
    }
