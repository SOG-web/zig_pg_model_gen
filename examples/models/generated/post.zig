// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: ./examples/schemas/post.json
// To regenerate: zig run scripts/generate_model.zig -- ./examples/schemas/post.json

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("base.zig").BaseModel;
const QueryBuilder = @import("query.zig").QueryBuilder;
const Transaction = @import("transaction.zig").Transaction;

// Related models
const AuthUser = @import("auth_user.zig").AuthUser;

const Post = @This();

    // Fields
id: []const u8,
author_id: []const u8,
title: []const u8,
slug: []const u8,
content: []const u8,
published: bool,
created_at: i64,
updated_at: i64,
deleted_at: ?i64,


    // Input type for creating new records
    pub const CreateInput = struct {
        author_id: []const u8,
        title: []const u8,
        slug: []const u8,
        content: []const u8,
        published: ?bool = null,
    };

    // Input type for updating existing records
    pub const UpdateInput = struct {
        author_id: ?[]const u8 = null,
        title: ?[]const u8 = null,
        slug: ?[]const u8 = null,
        content: ?[]const u8 = null,
        published: ?bool = null,
    };

    // Model configuration
    pub fn tableName() []const u8 {
        return "posts";
    }

    pub fn createTableSQL() []const u8 {
        return
            \\CREATE TABLE IF NOT EXISTS posts (
            \\    id UUID PRIMARY KEY NOT NULL DEFAULT gen_random_uuid(),
            \\    author_id UUID NOT NULL,
            \\    title TEXT NOT NULL,
            \\    slug TEXT NOT NULL UNIQUE,
            \\    content TEXT NOT NULL,
            \\    published BOOLEAN NOT NULL DEFAULT FALSE,
            \\    created_at TIMESTAMP NOT NULL DEFAULT now(),
            \\    updated_at TIMESTAMP NOT NULL DEFAULT now(),
            \\    deleted_at TIMESTAMP,
            \\    CONSTRAINT author FOREIGN KEY (author_id) REFERENCES auth_users(id) ON DELETE CASCADE
            \\)
        ;
    }

    pub fn createIndexSQL() []const []const u8 {
        return &[_][]const u8{
            "CREATE INDEX IF NOT EXISTS idx_posts_author ON posts (author_id)",
            "CREATE UNIQUE INDEX IF NOT EXISTS idx_posts_slug ON posts (slug)",
        };
    }

    pub fn dropIndexSQL() []const []const u8 {
        return &[_][]const u8{
            "DROP INDEX IF EXISTS idx_posts_author",
            "DROP INDEX IF EXISTS idx_posts_slug",
        };
    }

    pub fn insertSQL() []const u8 {
        return
            \\INSERT INTO posts (
            \\    author_id, title, slug, content, published
            \\) VALUES ($1, $2, $3, $4, COALESCE($5, FALSE))
            \\RETURNING id
        ;
    }

    pub fn insertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        ?bool,
    } {
        return .{
            data.author_id,
            data.title,
            data.slug,
            data.content,
            data.published,
        };
    }

    pub fn updateSQL() []const u8 {
        return
            \\UPDATE posts SET
            \\    author_id = COALESCE($2, author_id),
            \\    title = COALESCE($3, title),
            \\    slug = COALESCE($4, slug),
            \\    content = COALESCE($5, content),
            \\    published = COALESCE($6, published),
            \\    updated_at = CURRENT_TIMESTAMP
            \\WHERE id = $1
        ;
    }

    pub fn updateParams(id: []const u8, data: UpdateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?bool,
    } {
        return .{
            id,
            data.author_id,
            data.title,
            data.slug,
            data.content,
            data.published,
        };
    }

    pub fn upsertSQL() []const u8 {
        return
            \\INSERT INTO posts (
            \\    author_id, title, slug, content, published
            \\) VALUES ($1, $2, $3, $4, $5)
            \\ON CONFLICT (slug) DO UPDATE SET
            \\    author_id = EXCLUDED.author_id,
            \\    title = EXCLUDED.title,
            \\    content = EXCLUDED.content,
            \\    published = EXCLUDED.published,
            \\    updated_at = CURRENT_TIMESTAMP
            \\RETURNING id
        ;
    }

    pub fn upsertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        ?bool,
    } {
        return .{
            data.author_id,
            data.title,
            data.slug,
            data.content,
            data.published,
        };
    }

    const base = BaseModel(Post);
    // DDL operations
    pub const createTable = base.createTable;

    pub const dropTable = base.dropTable;

    pub const createIndexes = base.createIndexes;

    pub const dropIndexes = base.dropIndexes;

    pub const truncate = base.truncate;

    pub const tableExists = base.tableExists;

    // CRUD operations
    pub const findById = base.findById;

    pub const findAll = base.findAll;

    pub const insert = base.insert;

    pub const insertAndReturn = base.insertAndReturn;

    pub const update = base.update;

    pub const updateAndReturn = base.updateAndReturn;

    pub const upsert = base.upsert;

    pub const upsertAndReturn = base.upsertAndReturn;

    pub const softDelete = base.softDelete;

    pub const hardDelete = base.hardDelete;

    pub const count = base.count;

    pub const fromRow = base.fromRow;

    pub fn query() QueryBuilder(Post, UpdateInput) {
        return QueryBuilder(Post, UpdateInput).init();
    }


    /// JSON-safe response struct with UUIDs as hex strings
    pub const JsonResponse = struct {
        id: [36]u8,
        author_id: [36]u8,
        title: []const u8,
        slug: []const u8,
        content: []const u8,
        published: bool,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
    };

    /// Convert model to JSON-safe response with UUIDs as hex strings
    pub fn toJsonResponse(self: Post) !JsonResponse {
        return JsonResponse{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .author_id = try pg.uuidToHex(&self.author_id[0..16].*),
            .title = self.title,
            .slug = self.slug,
            .content = self.content,
            .published = self.published,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
        };
    }

    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
    pub const JsonResponseSafe = struct {
        id: [36]u8,
        author_id: [36]u8,
        title: []const u8,
        slug: []const u8,
        content: []const u8,
        published: bool,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
    };

    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
    pub fn toJsonResponseSafe(self: Post) !JsonResponseSafe {
        return JsonResponseSafe{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .author_id = try pg.uuidToHex(&self.author_id[0..16].*),
            .title = self.title,
            .slug = self.slug,
            .content = self.content,
            .published = self.published,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
        };
    }
    // Relationship methods
    /// Fetch the related AuthUser record for this Post
    pub fn fetchAuthor(self: *const Post, db: *pg.Pool, allocator: std.mem.Allocator) !?AuthUser {
        return AuthUser.findById(db, allocator, self.author_id);
    }

    // Transaction support
    pub const TransactionType = Transaction(Post);

    pub fn beginTransaction(conn: *pg.Conn) !TransactionType {
        return TransactionType.begin(conn);
    }
