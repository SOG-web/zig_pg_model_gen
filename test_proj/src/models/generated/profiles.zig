// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: profiles.zig
// To regenerate: zig run scripts/generate_model.zig -- profiles.zig

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("base.zig").BaseModel;
const QueryBuilder = @import("query.zig").QueryBuilder;
const Transaction = @import("transaction.zig").Transaction;

// Related models
const Users = @import("users.zig");

const Profiles = @This();

// Fields
id: []const u8,
user_id: []const u8,
bio: ?[]const u8,
avatar_url: ?[]const u8,
website: ?[]const u8,
location: ?[]const u8,
date_of_birth: ?i64,
created_at: i64,
updated_at: i64,
    pub const FieldEnum = enum {
        id,
        user_id,
        bio,
        avatar_url,
        website,
        location,
        date_of_birth,
        created_at,
        updated_at,
    };


    // Input type for creating new records
    pub const CreateInput = struct {
        user_id: []const u8,
        bio: ?[]const u8 = null,
        avatar_url: ?[]const u8 = null,
        website: ?[]const u8 = null,
        location: ?[]const u8 = null,
        date_of_birth: ?i64 = null,
    };

    // Input type for updating existing records
    pub const UpdateInput = struct {
        user_id: ?[]const u8 = null,
        bio: ?[]const u8 = null,
        avatar_url: ?[]const u8 = null,
        website: ?[]const u8 = null,
        location: ?[]const u8 = null,
        date_of_birth: ?i64 = null,
        updated_at: ?i64 = null,
    };

    // Model configuration
    pub fn tableName() []const u8 {
        return "profiles";
    }

    pub fn insertSQL() []const u8 {
        return
            \\INSERT INTO profiles (
            \\    user_id, bio, avatar_url, website, location, date_of_birth
            \\) VALUES ($1, $2, $3, $4, $5, $6)
            \\RETURNING id
        ;
    }

    pub fn insertParams(data: CreateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?i64,
    } {
        return .{
            data.user_id,
            data.bio,
            data.avatar_url,
            data.website,
            data.location,
            data.date_of_birth,
        };
    }

    pub fn updateSQL() []const u8 {
        return
            \\UPDATE profiles SET
            \\    user_id = COALESCE($2, user_id),
            \\    bio = COALESCE($3, bio),
            \\    avatar_url = COALESCE($4, avatar_url),
            \\    website = COALESCE($5, website),
            \\    location = COALESCE($6, location),
            \\    date_of_birth = COALESCE($7, date_of_birth),
            \\    updated_at = COALESCE($8, updated_at),
            \\    updated_at = CURRENT_TIMESTAMP
            \\WHERE id = $1
        ;
    }

    pub fn updateParams(id: []const u8, data: UpdateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?i64,
        ?i64,
    } {
        return .{
            id,
            data.user_id,
            data.bio,
            data.avatar_url,
            data.website,
            data.location,
            data.date_of_birth,
            data.updated_at,
        };
    }

    pub fn upsertSQL() []const u8 {
        return
            \\INSERT INTO profiles (
            \\    user_id, bio, avatar_url, website, location, date_of_birth
            \\) VALUES ($1, $2, $3, $4, $5, $6)
            \\ON CONFLICT (user_id) DO UPDATE SET
            \\    bio = EXCLUDED.bio,
            \\    avatar_url = EXCLUDED.avatar_url,
            \\    website = EXCLUDED.website,
            \\    location = EXCLUDED.location,
            \\    date_of_birth = EXCLUDED.date_of_birth,
            \\    updated_at = CURRENT_TIMESTAMP
            \\RETURNING id
        ;
    }

    pub fn upsertParams(data: CreateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?i64,
    } {
        return .{
            data.user_id,
            data.bio,
            data.avatar_url,
            data.website,
            data.location,
            data.date_of_birth,
        };
    }

    const base = BaseModel(Profiles);
    // DDL operations

    pub const truncate = base.truncate;

    pub const tableExists = base.tableExists;

    // CRUD operations
    pub const findById = base.findById;

    pub const findAll = base.findAll;

    pub const insert = base.insert;

    pub const insertAndReturn = base.insertAndReturn;

    pub const update = base.update;

    pub const updateAndReturn = base.updateAndReturn;

    pub const upsert = base.upsert;

    pub const upsertAndReturn = base.upsertAndReturn;

    pub const softDelete = base.softDelete;

    pub const hardDelete = base.hardDelete;

    pub const count = base.count;

    pub const fromRow = base.fromRow;

    pub fn query() QueryBuilder(Profiles, UpdateInput, FieldEnum) {
        return QueryBuilder(Profiles, UpdateInput, FieldEnum).init();
    }


    /// JSON-safe response struct with UUIDs as hex strings
    pub const JsonResponse = struct {
        id: [36]u8,
        user_id: [36]u8,
        bio: ?[]const u8,
        avatar_url: ?[]const u8,
        website: ?[]const u8,
        location: ?[]const u8,
        date_of_birth: ?i64,
        created_at: i64,
        updated_at: i64,
    };

    /// Convert model to JSON-safe response with UUIDs as hex strings
    pub fn toJsonResponse(self: Profiles) !JsonResponse {
        return JsonResponse{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .user_id = try pg.uuidToHex(&self.user_id[0..16].*),
            .bio = self.bio,
            .avatar_url = self.avatar_url,
            .website = self.website,
            .location = self.location,
            .date_of_birth = self.date_of_birth,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
        };
    }

    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
    pub const JsonResponseSafe = struct {
        id: [36]u8,
        user_id: [36]u8,
        bio: ?[]const u8,
        avatar_url: ?[]const u8,
        website: ?[]const u8,
        location: ?[]const u8,
        date_of_birth: ?i64,
        created_at: i64,
        updated_at: i64,
    };

    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
    pub fn toJsonResponseSafe(self: Profiles) !JsonResponseSafe {
        return JsonResponseSafe{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .user_id = try pg.uuidToHex(&self.user_id[0..16].*),
            .bio = self.bio,
            .avatar_url = self.avatar_url,
            .website = self.website,
            .location = self.location,
            .date_of_birth = self.date_of_birth,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
        };
    }
    // Relationship methods
    /// Fetch the related Users record for this Profiles
    pub fn fetchUser(self: *const Profiles, db: *pg.Pool, allocator: std.mem.Allocator) !?Users {
        return Users.findById(db, allocator, self.user_id);
    }

    // Transaction support
    pub const TransactionType = Transaction(Profiles);

    pub fn beginTransaction(conn: *pg.Conn) !TransactionType {
        return TransactionType.begin(conn);
    }
